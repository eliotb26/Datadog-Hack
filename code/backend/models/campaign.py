"""
SIGNAL — CampaignConcept Data Model
The output schema of Agent 3 (Campaign Generation Agent).
"""
from __future__ import annotations

import json
import uuid
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Channel(str, Enum):
    TWITTER = "twitter"
    LINKEDIN = "linkedin"
    INSTAGRAM = "instagram"
    NEWSLETTER = "newsletter"


class CampaignConcept(BaseModel):
    """A single campaign concept generated by Agent 3."""

    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    company_id: Optional[str] = None
    trend_signal_id: Optional[str] = None

    headline: str = Field(..., description="Attention-grabbing headline (max ~15 words)")
    body_copy: str = Field(..., description="Campaign body copy (50–150 words)")
    visual_direction: str = Field(..., description="Notes describing the desired visual asset")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="Agent confidence (0–1)")
    channel_recommendation: Channel = Field(..., description="Best distribution channel")
    channel_reasoning: str = Field(..., description="Why this channel was selected")

    # Filled in by downstream integrations
    visual_asset_url: Optional[str] = None   # Flora AI
    safety_score: Optional[float] = None     # Modulate ToxMod
    safety_passed: bool = True

    status: str = "draft"   # draft | approved | posted | completed
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # ── DB helpers ──────────────────────────────────────────────

    def to_db_row(self) -> dict:
        """Flat dict for SQLite insertion into the campaigns table."""
        return {
            "id": self.id,
            "company_id": self.company_id,
            "trend_signal_id": self.trend_signal_id,
            "headline": self.headline,
            "body_copy": self.body_copy,
            "visual_direction": self.visual_direction,
            "visual_asset_url": self.visual_asset_url,
            "confidence_score": self.confidence_score,
            "channel_recommendation": self.channel_recommendation.value,
            "channel_reasoning": self.channel_reasoning,
            "safety_score": self.safety_score,
            "safety_passed": int(self.safety_passed),
            "status": self.status,
            "created_at": self.created_at.isoformat(),
        }

    @classmethod
    def from_db_row(cls, row: dict) -> "CampaignConcept":
        """Reconstruct from a SQLite row dict."""
        return cls(
            id=row["id"],
            company_id=row.get("company_id"),
            trend_signal_id=row.get("trend_signal_id"),
            headline=row["headline"],
            body_copy=row["body_copy"],
            visual_direction=row.get("visual_direction", ""),
            visual_asset_url=row.get("visual_asset_url"),
            confidence_score=float(row.get("confidence_score") or 0.0),
            channel_recommendation=Channel(row.get("channel_recommendation", "twitter")),
            channel_reasoning=row.get("channel_reasoning", ""),
            safety_score=row.get("safety_score"),
            safety_passed=bool(row.get("safety_passed", 1)),
            status=row.get("status", "draft"),
            created_at=datetime.fromisoformat(row["created_at"]) if row.get("created_at") else datetime.utcnow(),
        )

    def to_dict(self) -> dict:
        return self.model_dump(mode="json")


class CampaignGenerationRequest(BaseModel):
    """Input to Agent 3."""

    company: "CompanyProfile"
    trend_signals: List["TrendSignal"]
    prompt_weights: Dict[str, Any] = Field(
        default_factory=dict,
        description=(
            "Learned weights from Loop 1. Numeric keys are multipliers "
            "(e.g. 'tone_weight': 1.2); 'learned_preferences' is a free-text hint."
        ),
    )
    n_concepts: int = Field(default=3, ge=1, le=5)


class CampaignGenerationResponse(BaseModel):
    """Output from Agent 3's run_campaign_agent."""

    company_id: str
    trend_signal_ids: List[str]
    concepts: List[CampaignConcept]
    agent_version: str = "3.0"
    generated_at: datetime = Field(default_factory=datetime.utcnow)
    latency_ms: Optional[int] = None
    success: bool = True


# Resolve forward refs
from .company import CompanyProfile  # noqa: E402
from .signal import TrendSignal      # noqa: E402

CampaignGenerationRequest.model_rebuild()


# ---------------------------------------------------------------------------
# Agent 4 models — ChannelScore and DistributionPlan
# ---------------------------------------------------------------------------

class ChannelScore(BaseModel):
    """Fit score for a single distribution channel, computed by Agent 4's tools."""

    channel: str = Field(..., description="twitter | linkedin | instagram | newsletter")
    fit_score: float = Field(..., ge=0.0, le=1.0, description="Overall composite fit score")
    length_fit: float = Field(..., ge=0.0, le=1.0, description="Content length suitability")
    visual_fit: float = Field(..., ge=0.0, le=1.0, description="Visual asset suitability")
    audience_fit: float = Field(..., ge=0.0, le=1.0, description="Audience match quality")
    reasoning: str = Field(default="", description="One-line reasoning for this score")


class DistributionPlan(BaseModel):
    """
    Distribution plan for one campaign concept — output of Agent 4.

    Specifies the best channel, posting time, and how to adapt the campaign copy
    for that channel's format requirements.
    """

    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    campaign_id: str = Field(..., description="ID of the CampaignConcept being routed")
    company_id: str = Field(..., description="ID of the owning company")

    recommended_channel: str = Field(
        ..., description="Best channel: twitter | linkedin | instagram | newsletter"
    )
    channel_scores: List[ChannelScore] = Field(
        default_factory=list, description="Scores for all four channels"
    )

    posting_time: str = Field(
        ..., description="Optimal posting window, e.g. 'Tuesday 8–10 AM ET'"
    )
    format_adaptation: str = Field(
        ..., description="Specific instructions for adapting the copy to the channel format"
    )
    character_count_target: Optional[int] = Field(
        default=None, description="Target character count for the chosen channel"
    )
    visual_required: bool = Field(
        default=False, description="Whether a visual asset is required for this channel"
    )
    reasoning: str = Field(
        ..., description="2–3 sentence explanation of why this channel was chosen"
    )
    confidence: float = Field(
        default=0.5, ge=0.0, le=1.0,
        description="Agent 4's confidence in this distribution recommendation"
    )
    created_at: datetime = Field(default_factory=datetime.utcnow)

    def to_db_row(self) -> dict:
        """Serialize to a flat dict for SQLite storage."""
        return {
            "id": self.id,
            "campaign_id": self.campaign_id,
            "company_id": self.company_id,
            "recommended_channel": self.recommended_channel,
            "channel_scores": json.dumps([s.model_dump() for s in self.channel_scores]),
            "posting_time": self.posting_time,
            "format_adaptation": self.format_adaptation,
            "character_count_target": self.character_count_target,
            "visual_required": int(self.visual_required),
            "reasoning": self.reasoning,
            "confidence": self.confidence,
            "created_at": self.created_at.isoformat(),
        }

    def best_score(self) -> Optional["ChannelScore"]:
        """Return the ChannelScore for the recommended channel."""
        for s in self.channel_scores:
            if s.channel.lower() == self.recommended_channel.lower():
                return s
        return None
